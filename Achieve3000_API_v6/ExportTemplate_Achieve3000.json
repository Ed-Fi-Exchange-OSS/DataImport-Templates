{
    "title": "ExportTemplate_Achieve3000",
    "description": "ExportTemplate Achieve3000 v2",
    "apiVersion": "6.0",
    "template": {
        "maps": [
            {
                "name": "DataMap_Achieve3000_ACHIEVE3000-V1",
                "resourcePath": "/ed-fi/studentAssessments",
                "columnHeaders": [
                    "District ID",
                    "District",
                    "District Status",
                    "Purchasing Entity",
                    "School ID",
                    "School",
                    "User ID",
                    "Student ID",
                    "Student Name",
                    "Grade",
                    "Language ID",
                    "Language",
                    "ELL",
                    "SPED",
                    "Editions",
                    "Total Logins",
                    "First Login",
                    "Last Login",
                    "After School Logins",
                    "Activities",
                    "Average First Try Score",
                    "Passing Activities",
                    "Invalid Activities",
                    "Total Activities",
                    "Average Weekly Activities",
                    "Writing Assignments",
                    "Program Hours",
                    "Pre-Test Date",
                    "Pre-Test Reading Level",
                    "Pre-Test Lexile",
                    "Interim Test Date",
                    "Interim Test Reading Level",
                    "Interim Test Lexile",
                    "Post-Test Date",
                    "Post-Test Reading Level",
                    "Post-Test Lexile",
                    "Last Adjustment Date",
                    "Current Reading Level",
                    "Current Lexile Level",
                    "Expected Lexile Growth",
                    "College and Career Readiness (current)",
                    "College and Career Readiness (pre-test)",
                    "Manual Adjustments",
                    "Top Career Cluster",
                    "Top Career Name",
                    "Reading Connections:Summarization",
                    "Reading Connections:Generate Questions",
                    "Reading Connections:Setting the Purpose",
                    "Program",
                    "DI_AdministrationDate",
                    "DI_SchoolYear",
                    "DI_StudentAssessmentIdentifier"
                ],
                "map": {
                    "studentAssessmentIdentifier": {
                        "Column": "DI_StudentAssessmentIdentifier"
                    },
                    "assessmentReference": {
                        "assessmentIdentifier": "ACHIEVE3000-V1",
                        "namespace": "uri://achieve3000.com/Assessment"
                    },
                    "schoolYearTypeReference": {
                        "schoolYear": {
                            "Column": "DI_SchoolYear"
                        }
                    },
                    "studentReference": {
                        "studentUniqueId": {
                            "Column": "Student ID"
                        }
                    },
                    "administrationDate": {
                        "Column": "DI_AdministrationDate"
                    },
                    "performanceLevels": [
                        {
                            "assessmentReportingMethodDescriptor": "uri://achieve3000.com/AssessmentReportingMethodDescriptor#College and Career Readiness",
                            "performanceLevelDescriptor": {
                                "Column": "College and Career Readiness (current)",
                                "Lookup": "ACHIEVE3000_CollegeAndCarrerReadiness_LU"
                            }
                        }
                    ],
                    "scoreResults": [
                        {
                            "assessmentReportingMethodDescriptor": "uri://achieve3000.com/AssessmentReportingMethodDescriptor#Reading Level",
                            "resultDatatypeTypeDescriptor": "uri://ed-fi.org/ResultDatatypeTypeDescriptor#Integer",
                            "result": {
                                "Column": "Current Reading Level"
                            }
                        },
                        {
                            "assessmentReportingMethodDescriptor": "uri://ed-fi.org/AssessmentReportingMethodDescriptor#Lexile Measure",
                            "resultDatatypeTypeDescriptor": "uri://ed-fi.org/ResultDatatypeTypeDescriptor#Integer",
                            "result": {
                                "Column": "Current Lexile Level"
                            }
                        },
                        {
                            "assessmentReportingMethodDescriptor": "uri://achieve3000.com/AssessmentReportingMethodDescriptor#Expected Lexile Growth",
                            "resultDatatypeTypeDescriptor": "uri://ed-fi.org/ResultDatatypeTypeDescriptor#Level",
                            "result": {
                                "Column": "Expected Lexile Growth"
                            }
                        }
                    ],
                    "whenAssessedGradeLevelDescriptor": {
                        "Column": "Grade",
                        "Lookup": "ACHIEVE3000_GradeLevel_LU"
                    }
                },
                "customFileProcessor": "ACHIEVE3000_CFP",
                "attribute": null
            }
        ],
        "bootstraps": [
            {
                "name": "Achieve3000_ARMD",
                "resourcePath": "/ed-fi/assessmentReportingMethodDescriptors",
                "data": [
                    {
                        "codeValue": "Expected Lexile Growth",
                        "description": "Expected Lexile Growth",
                        "namespace": "uri://achieve3000.com/AssessmentReportingMethodDescriptor",
                        "shortDescription": "Expected Lexile Growth"
                    },
                    {
                        "codeValue": "Reading Level",
                        "description": "Reading Level",
                        "namespace": "uri://achieve3000.com/AssessmentReportingMethodDescriptor",
                        "shortDescription": "Reading Level"
                    },
                    {
                        "codeValue": "College and Career Readiness",
                        "description": "College and Career Readiness",
                        "namespace": "uri://achieve3000.com/AssessmentReportingMethodDescriptor",
                        "shortDescription": "College and Career Readiness"
                    }
                ]
            },
            {
                "name": "Achieve3000_Assessment_ACHIEVE3000-V1",
                "resourcePath": "/ed-fi/assessments",
                "data": {
                    "assessmentIdentifier": "ACHIEVE3000-V1",
                    "assessmentTitle": "Achieve 3000",
                    "namespace": "uri://achieve3000.com/Assessment",
                    "assessedGradeLevels": [
                        {
                            "gradeLevelDescriptor": "uri://ed-fi.org/GradeLevelDescriptor#Second grade"
                        },
                        {
                            "gradeLevelDescriptor": "uri://ed-fi.org/GradeLevelDescriptor#Third grade"
                        },
                        {
                            "gradeLevelDescriptor": "uri://ed-fi.org/GradeLevelDescriptor#Fourth grade"
                        },
                        {
                            "gradeLevelDescriptor": "uri://ed-fi.org/GradeLevelDescriptor#Fifth grade"
                        },
                        {
                            "gradeLevelDescriptor": "uri://ed-fi.org/GradeLevelDescriptor#Sixth grade"
                        },
                        {
                            "gradeLevelDescriptor": "uri://ed-fi.org/GradeLevelDescriptor#Seventh grade"
                        },
                        {
                            "gradeLevelDescriptor": "uri://ed-fi.org/GradeLevelDescriptor#Eighth grade"
                        },
                        {
                            "gradeLevelDescriptor": "uri://ed-fi.org/GradeLevelDescriptor#Ninth grade"
                        },
                        {
                            "gradeLevelDescriptor": "uri://ed-fi.org/GradeLevelDescriptor#Tenth grade"
                        },
                        {
                            "gradeLevelDescriptor": "uri://ed-fi.org/GradeLevelDescriptor#Eleventh grade"
                        },
                        {
                            "gradeLevelDescriptor": "uri://ed-fi.org/GradeLevelDescriptor#Twelfth grade"
                        },
                        {
                            "gradeLevelDescriptor": "uri://ed-fi.org/GradeLevelDescriptor#No grade level"
                        }
                    ],
                    "assessmentCategoryDescriptor": "uri://ed-fi.org/AssessmentCategoryDescriptor#Reading readiness test",
                    "academicSubjects": [
                        {
                            "academicSubjectDescriptor": "uri://ed-fi.org/AcademicSubjectDescriptor#Reading"
                        }
                    ],
                    "scores": [
                        {
                            "assessmentReportingMethodDescriptor": "uri://achieve3000.com/AssessmentReportingMethodDescriptor#Reading Level",
                            "resultDatatypeTypeDescriptor": "uri://ed-fi.org/ResultDatatypeTypeDescriptor#Integer"
                        },
                        {
                            "assessmentReportingMethodDescriptor": "uri://ed-fi.org/AssessmentReportingMethodDescriptor#Lexile Measure",
                            "resultDatatypeTypeDescriptor": "uri://ed-fi.org/ResultDatatypeTypeDescriptor#Integer"
                        },
                        {
                            "assessmentReportingMethodDescriptor": "uri://achieve3000.com/AssessmentReportingMethodDescriptor#Expected Lexile Growth",
                            "resultDatatypeTypeDescriptor": "uri://ed-fi.org/ResultDatatypeTypeDescriptor#Level"
                        }
                    ],
                    "performanceLevels": [
                        {
                            "assessmentReportingMethodDescriptor": "uri://achieve3000.com/AssessmentReportingMethodDescriptor#College and Career Readiness",
                            "performanceLevelDescriptor": "uri://achieve3000.com/PerformanceLevelDescriptor#Approaches",
                            "resultDatatypeTypeDescriptor": "uri://ed-fi.org/ResultDatatypeTypeDescriptor#Level"
                        },
                        {
                            "assessmentReportingMethodDescriptor": "uri://achieve3000.com/AssessmentReportingMethodDescriptor#College and Career Readiness",
                            "performanceLevelDescriptor": "uri://achieve3000.com/PerformanceLevelDescriptor#Exceeds",
                            "resultDatatypeTypeDescriptor": "uri://ed-fi.org/ResultDatatypeTypeDescriptor#Level"
                        },
                        {
                            "assessmentReportingMethodDescriptor": "uri://achieve3000.com/AssessmentReportingMethodDescriptor#College and Career Readiness",
                            "performanceLevelDescriptor": "uri://achieve3000.com/PerformanceLevelDescriptor#Falls far below",
                            "resultDatatypeTypeDescriptor": "uri://ed-fi.org/ResultDatatypeTypeDescriptor#Level"
                        },
                        {
                            "assessmentReportingMethodDescriptor": "uri://achieve3000.com/AssessmentReportingMethodDescriptor#College and Career Readiness",
                            "performanceLevelDescriptor": "uri://achieve3000.com/PerformanceLevelDescriptor#Meets",
                            "resultDatatypeTypeDescriptor": "uri://ed-fi.org/ResultDatatypeTypeDescriptor#Level"
                        }
                    ]
                }
            },
            {
                "name": "Achieve3000_PLD",
                "resourcePath": "/ed-fi/performanceLevelDescriptors",
                "data": [
                    {
                        "codeValue": "Approaches",
                        "description": "Approaches",
                        "namespace": "uri://achieve3000.com/PerformanceLevelDescriptor",
                        "shortDescription": "Approaches"
                    },
                    {
                        "codeValue": "Exceeds",
                        "description": "Exceeds",
                        "namespace": "uri://achieve3000.com/PerformanceLevelDescriptor",
                        "shortDescription": "Exceeds"
                    },
                    {
                        "codeValue": "Falls far below",
                        "description": "Falls far below",
                        "namespace": "uri://achieve3000.com/PerformanceLevelDescriptor",
                        "shortDescription": "Falls far below"
                    },
                    {
                        "codeValue": "Meets",
                        "description": "Meets",
                        "namespace": "uri://achieve3000.com/PerformanceLevelDescriptor",
                        "shortDescription": "Meets"
                    }
                ]
            }
        ],
        "lookups": [
            {
                "sourceTable": "ACHIEVE3000_CollegeAndCarrerReadiness_LU",
                "key": "Approaches",
                "value": "uri://achieve3000.com/PerformanceLevelDescriptor#Approaches"
            },
            {
                "sourceTable": "ACHIEVE3000_CollegeAndCarrerReadiness_LU",
                "key": "Exceeds",
                "value": "uri://achieve3000.com/PerformanceLevelDescriptor#Exceeds"
            },
            {
                "sourceTable": "ACHIEVE3000_CollegeAndCarrerReadiness_LU",
                "key": "Falls far below",
                "value": "uri://achieve3000.com/PerformanceLevelDescriptor#Falls far below"
            },
            {
                "sourceTable": "ACHIEVE3000_CollegeAndCarrerReadiness_LU",
                "key": "Meets",
                "value": "uri://achieve3000.com/PerformanceLevelDescriptor#Meets"
            },
            {
                "sourceTable": "ACHIEVE3000_GradeLevel_LU",
                "key": "0",
                "value": "uri://ed-fi.org/GradeLevelDescriptor#Kindergarten"
            },
            {
                "sourceTable": "ACHIEVE3000_GradeLevel_LU",
                "key": "1",
                "value": "uri://ed-fi.org/GradeLevelDescriptor#First grade"
            },
            {
                "sourceTable": "ACHIEVE3000_GradeLevel_LU",
                "key": "10",
                "value": "uri://ed-fi.org/GradeLevelDescriptor#Tenth grade"
            },
            {
                "sourceTable": "ACHIEVE3000_GradeLevel_LU",
                "key": "11",
                "value": "uri://ed-fi.org/GradeLevelDescriptor#Eleventh grade"
            },
            {
                "sourceTable": "ACHIEVE3000_GradeLevel_LU",
                "key": "12",
                "value": "uri://ed-fi.org/GradeLevelDescriptor#Twelfth grade"
            },
            {
                "sourceTable": "ACHIEVE3000_GradeLevel_LU",
                "key": "2",
                "value": "uri://ed-fi.org/GradeLevelDescriptor#Second grade"
            },
            {
                "sourceTable": "ACHIEVE3000_GradeLevel_LU",
                "key": "3",
                "value": "uri://ed-fi.org/GradeLevelDescriptor#Third grade"
            },
            {
                "sourceTable": "ACHIEVE3000_GradeLevel_LU",
                "key": "4",
                "value": "uri://ed-fi.org/GradeLevelDescriptor#Fifth grade"
            },
            {
                "sourceTable": "ACHIEVE3000_GradeLevel_LU",
                "key": "6",
                "value": "uri://ed-fi.org/GradeLevelDescriptor#Sixth grade"
            },
            {
                "sourceTable": "ACHIEVE3000_GradeLevel_LU",
                "key": "7",
                "value": "uri://ed-fi.org/GradeLevelDescriptor#Seventh grade"
            },
            {
                "sourceTable": "ACHIEVE3000_GradeLevel_LU",
                "key": "8",
                "value": "uri://ed-fi.org/GradeLevelDescriptor#Eighth grade"
            },
            {
                "sourceTable": "ACHIEVE3000_GradeLevel_LU",
                "key": "9",
                "value": "uri://ed-fi.org/GradeLevelDescriptor#Ninth grade"
            }
        ],
        "supplementalInformation": null,
        "preprocessors": [
            {
                "name": "ACHIEVE3000_CFP",
                "scriptContent": "[CmdletBinding()]\r\nParam(\r\n    [parameter(Mandatory = $true, ValueFromPipeline = $true)][string]$line\r\n)\r\n\r\n#####################################################\r\n### Ed-Fi ODS v3+\r\n### Assessment: Sample Test \r\n### Script: Custom File Processor\r\n#####################################################\r\n\r\n\r\n# Handle start of processing\r\nbegin {\r\n\r\n    # Set up the statistics\r\n    # validations: Hashtable of HashTables with properties for each screening period, and each screening period will have statistics like number of records not loaded, and detailed info\r\n    <#\r\n    #>\r\n    $global:statistics = @{\r\n        \"rowsProcessed\" = 0\r\n        \"rowsLoaded\"    = 0\r\n        \"validations\"   = @{}\r\n    }\r\n\r\n    # Prepare some other variables\r\n    $currentLineNumber = 0\r\n    $global:inputHeaders = @()\r\n    $global:headersLookup = @{}\r\n\r\n    ### Helper functions\r\n\r\n    ## ODS functions\r\n    \r\n    function Get-StudentUniqueIdType ($apiVersion) {\r\n        <#\r\n            .SYNOPSIS\r\n                Determines whether the value in Student.studentUniqueId is a District or State ID value. \r\n    \r\n            .DESCRIPTION\r\n                Determining the studentUniqueId value type is done by querying the /students endpoint for 10 \r\n                students and then checking either the values in the identificationCodes[] array on either the\r\n                Student record (v2.5+ API) or the studentEducationOrganizationAssociation record (v3.x API) to\r\n                see whether the District or State ID matches the StudentUniqueId value. 10 students are checked \r\n                to make sure there aren't any discrepancies.\r\n    \r\n                NOTE: Only \"District\" and \"State\" Student ID types are used in this check; all others are ignored!\r\n    \r\n            .PARAMETER ApiVersion\r\n                The version number of the API as set in $DataImport.ApiVersion. For whatever reason the $DataImport\r\n                object is not directly addressable from within a module.\r\n    \r\n            .OUTPUTS\r\n                A string representing the type of ID stored in studentUniqueId. This value  will be either\r\n                'District' or 'State'.\r\n    \r\n                Throws an error on any failure to connect to or query the API or if one or more students of\r\n                the 10 checked have a different ID value type (e.g. one has 'District' while the rest have \r\n                'State'). Also throws an error if a match can't be made on any of the 10 students checked.\r\n    \r\n            .EXAMPLE\r\n                $studentUniqueIdType = Get-StudentUniqueIdType -apiVersion $DataImport.ApiVersion\r\n        #>\r\n    \r\n        # Do sanity checks on parameters\r\n        if (!$apiVersion) { throw \"The apiVersion parameter must be set to a valid value.\" }\r\n    \r\n        # Processing depends on API version\r\n        # Only valid for apis version 3 and above\r\n        \r\n        if ($apiVersion.StartsWith(\"3.\") -or $apiVersion.StartsWith(\"5.\") -or $apiVersion.StartsWith(\"6.\")) {\r\n            # Query for 10 students (whatever comes back first - and yes, this could be flaky)\r\n            try {\r\n                $jsonResponse = Invoke-OdsApiRequest -RequestPath \"/ed-fi/studentEducationOrganizationAssociations?limit=10\"\r\n                $seoas = ConvertFrom-Json $jsonResponse\r\n            }\r\n            catch {\r\n                throw $_\r\n            }\r\n            if ($seoas.Count -eq 0) { throw \"Unable to determine StudentUniqueId type as no StudentEducationOrganizationAssociations were found in the ODS.\" }\r\n        \r\n            # Iterate the list of students checking studentUniqueId against the ID code types. These should all be the same but you know student data...\r\n            $ret = \"\"\r\n            foreach ($seoa in $seoas) {\r\n                foreach ($idCode in $seoa.studentIdentificationCodes) {\r\n                    if ($seoa.studentReference.studentUniqueId -eq $idCode.identificationCode) {\r\n                        $codeType = $idCode.studentIdentificationSystemDescriptor.Split(\"#\")\r\n                        $codeType = $codeType[1]\r\n                        if ($codeType -in @(\"District\", \"State\")) {\r\n                            if ($ret -eq \"\") { $ret = $codeType }\r\n                            elseif ($codeType -ne $ret) { \r\n                                throw \"Unable to determine studentUniqueId type as StudentEducationOrganizationAssociations have been found with both District and State ID values in studentUniqueId\" \r\n                            }\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n        \r\n            # If we got here then all 10 students had the same type of studentUniqueId value, so return that type\r\n            return $ret\r\n        }\r\n        else {\r\n            throw \"Attempt to connect to a version $($apiVersion) API, which is unsupported.\"\r\n        }\r\n        \r\n    }\r\n\r\n    function Get-StudentsIdMap ($apiVersion, $studentIdTypeCode) {\r\n        <#\r\n        .SYNOPSIS\r\n            Load from ODS studentId mapping from a given studentId type to its corresponding UniqueStudentId. $studentIdTypeCode valid values 'District','State'\r\n\r\n        .DESCRIPTION\r\n            Loads StudentUniqueId mapped to a passed studentId type from the ODS. \r\n            This data can then be used to look up a StudentUniqueId value by a specific studentIdType.\r\n\r\n        .PARAMETER ApiVersion\r\n            The version number of the API as set in $DataImport.ApiVersion. For whatever reason the $DataImport\r\n            object is not directly addressable from within a module.\r\n\r\n        .PARAMETER StudentIdTypeCode\r\n            The studentId Type that needs to be mapped to StudentUniqueId.\r\n\r\n        .OUTPUTS\r\n            A complex HashMap of values that you can treat as an object. The format is:\r\n            - StudentIdMap: Hashmap where keys are the desired studentIdType IdentificationCode value and the value is the StudentUniqueId from ODS\r\n                - Student Records (Key: StudentIdType IdentificationCode from ODS; Value: StudentUniqueId\r\n            \r\n            Throws an error on any failure to connect to or query the API or if one or more students of\r\n            the 10 checked have a different ID value type (e.g. one has 'District' while the rest have \r\n            'State')\r\n\r\n        .EXAMPLE\r\n            $students = Get-StudentsIdMap -apiVersion $DataImport.ApiVersion -studentIdTypeCode \"State\"\r\n        #>\r\n\r\n        # Set up some basic varialbes\r\n        $ret = @{\r\n            \"StudentIdMap\" = @{}\r\n            # \"DuplicateStudents\"         = @()\r\n            # \"NoAdditionalIdValuesFound\" = 0\r\n        }\r\n        $continue = $true\r\n        $offset = 0\r\n        $limit = 100\r\n\r\n        # Do sanity checks on parameters\r\n        if (!$apiVersion) { throw \"The apiVersion parameter must be set to a valid value.\" }\r\n\r\n        # Processing depends on the API version\r\n        if ($apiVersion.StartsWith(\"3.\") -or $apiVersion.StartsWith(\"5.\") -or $apiVersion.StartsWith(\"6.\")) {\r\n            try {\r\n                # Load the additional ID values\r\n                $continue = $true\r\n                $offset = 0\r\n                while ($continue) {\r\n                    $response = Invoke-OdsApiRequest -RequestPath \"/ed-fi/studentEducationOrganizationAssociations?limit=$limit&offset=$offset\"\r\n                    $students = ConvertFrom-Json $response\r\n                    if ($students.Count -gt 0) {\r\n                        foreach ($student in $students) {\r\n                            $studentUniqueId = $student.studentReference.studentUniqueId\r\n                            foreach ($idCode in $student.studentIdentificationCodes) {\r\n                                \r\n                                if ($idCode.studentIdentificationSystemDescriptor.Contains($studentIdTypeCode)) { \r\n                                    $ret.StudentIdMap[$idCode.identificationCode] = $studentUniqueId \r\n                                    # If found stop loop\r\n                                    break\r\n                                }\r\n                            }\r\n                        }\r\n                    }\r\n                    else {\r\n                        $continue = $false\r\n                    }\r\n                    $offset += $limit\r\n                }\r\n        \r\n                # Return the data\r\n                return $ret\r\n            }\r\n            catch {\r\n                throw $_\r\n            }\r\n        }\r\n        else {\r\n            throw \"Attempt to connect to a version $($apiVersion) API, which is unsupported.\"\r\n        }\r\n\r\n    }\r\n    \r\n    function Get-Students ($apiVersion) {\r\n        <#\r\n            .SYNOPSIS\r\n                Load all students and their assocaited ID values from the ODS \r\n\r\n            .DESCRIPTION\r\n                Loads StudentUniqueId, First Name, Last Name, Date of Birth, and all other Student ID values\r\n                from the ODS. This data can then be used to look up a StudentUniqueId value by any ID or by\r\n                FN/LN/DoB.\r\n\r\n            .PARAMETER ApiVersion\r\n                The version number of the API as set in $DataImport.ApiVersion. For whatever reason the $DataImport\r\n                object is not directly addressable from within a module.\r\n\r\n            .OUTPUTS\r\n                A complex HashMap of values that you can treat as an object. The format is:\r\n                - ValidStudents: Hashmap of Hashmaps\r\n                    - Student Records (Key: StudentUniqueId; Values: StudentUniqueId, FirstName, LastSurname, birthDate, DistrictId, StateId)\r\n                - DuplicateStudents: Array of Hashmaps\r\n                    - Student Records (Values: StudentUniqueId, FirstName, LastSurname, DateofBirth, DistrictId, StateId) \r\n                - NoAdditionalIdValuesFoundCount: Integer (v3 API only). Additional StudentID values have to be looked up in the \r\n                    StudentEducationOrganizationAssociations entity and we have seen cases where there is not a matching record in\r\n                    this entity for the one in the Students entity. In this case this value is incremented and the Student entry in \r\n                    the ValidStudents Hashmap will be missing the DistrictId and StateId values.\r\n\r\n                Throws an error on any failure to connect to or query the API or if one or more students of\r\n                the 10 checked have a different ID value type (e.g. one has 'District' while the rest have \r\n                'State')\r\n\r\n            .EXAMPLE\r\n                $students = Get-Students -apiVersion $DataImport.ApiVersion\r\n        #>\r\n\r\n        # Set up some basic varialbes\r\n        $ret = @{\"ValidStudents\" = @{}\r\n                \"DuplicateStudents\" = @()\r\n                \"NoAdditionalIdValuesFound\" = 0\r\n                }\r\n        $continue = $true\r\n        $offset = 0\r\n        $limit = 100\r\n\r\n        # Do sanity checks on parameters\r\n        if (!$apiVersion) { throw \"The apiVersion parameter must be set to a valid value.\" }\r\n\r\n        # Processing depends on the API version\r\n        if ($apiVersion.StartsWith(\"3.\") -or $apiVersion.StartsWith(\"5.\") -or $apiVersion.StartsWith(\"6.\")) {\r\n            # Load all students (but not their ID values - that's the second pass)\r\n            try {\r\n                while ($continue) { \r\n                    $jsonResponse = Invoke-OdsApiRequest -RequestPath \"/ed-fi/students?offset=$offset&limit=$limit\"\r\n                    $students = ConvertFrom-Json $jsonResponse\r\n                    \r\n                    # Process the students\r\n                    if ($students.Count -gt 0) {\r\n                        foreach ($student in $students) {\r\n                            # Capture the basic student data\r\n                            # $d = Get-ParsedDate -date $student.birthDate -inputFormat \"yyyy-MM-ddTHH:mm:ss\" -outputFormat \"M/d/yyyy\"\r\n                            $s = @{\r\n                                \"studentUniqueId\" = $student.studentUniqueId\r\n                                \"firstName\" = $student.firstName\r\n                                \"lastSurname\" = $student.lastSurname\r\n                                \"birthDate\" = $student.birthDate\r\n                            }\r\n\r\n                            # Check to see if the student is already in the list (this shouldn't happen but we've seen it in the past)\r\n                            if ($ret.ValidStudents[$student.studentUniqueId]) {\r\n                                # studentUniqueId value is already present in the list of students and this record should be added ot the DuplicateStudents array\r\n                                $ret.DuplicateStudents += $s\r\n                            }\r\n                            else {\r\n                                # Student is unique and should be added to the ValidStudents HashMap\r\n                                $ret.ValidStudents.Add($student.studentUniqueId, $s) | Out-Null\r\n                            }\r\n                        }\r\n                    }\r\n                    else {\r\n                        $continue = $false\r\n                    }\r\n                    $offset += $limit\r\n                }\r\n                \r\n                # Return the data\r\n                return $ret\r\n            }\r\n            catch {\r\n                throw $_\r\n            }\r\n        }\r\n        else { \r\n            throw \"Attempt to connect to a version $($apiVersion) API, which is unsupported.\"    \r\n        }\r\n        \r\n\r\n    }\r\n        \r\n    function Get-StudentUniqueId($studentList, $firstName, $lastSurname, $birthDate) {\r\n        <#\r\n            .SYNOPSIS\r\n                Return the appropriate studentUniqueId value for a student based on First Name, Last Name, and Date of Birth. \r\n\r\n            .DESCRIPTION\r\n                Looks up the studentUniqueId student using First Name, Last Name, and Birth Date (all three are required)\r\n\r\n            .PARAMETER studentList (required)\r\n                Hashmap of student information with the studentUniqueId value as key. The easiest way to get this data\r\n                is to call Get-Students and then pass  the \"ValidStudents\" hashmap that is returnd as part of the function\r\n                data to this function.\r\n\r\n            .PARAMETER firstName (required)\r\n                If provided, this will also be used to look up a studentUniqueId value. If you include this parameter then \r\n                you must also include lastSurname and birthDate.\r\n\r\n            .PARAMETER lastSurname (required)\r\n                If provided, this will also be used to look up a studentUniqueId value. If you include this parameter then \r\n                you must also include firstName and birthDate.\r\n\r\n            .PARAMETER birthDate (required)\r\n                If provided, this will also be used to look up a studentUniqueId value. If you include this parameter then \r\n                you must also include firstName and lastSurname.\r\n\r\n            .OUTPUTS\r\n                A studentUniqueId value that is valid for the ODS in use if successful.\r\n                \r\n                Throws an error if no matching StudentUniqueId value can be found for any number of reasons.\r\n\r\n                Throws an error if more than one student is matched using either ID or FN/LN/DoB searches\r\n\r\n                Throws an error on any other condition.\r\n\r\n            .EXAMPLE\r\n                $studentUniqueId = Get-StudentUniqueId -studentList $studentList -studentId $studentId -firstName $firstName -lastSurname $lastSurname -birthDate $birthDate\r\n        \r\n        #>\r\n\r\n        # Do some sanity checks on the parameters\r\n        if (!$studentList) { throw \"A list of students must be provided for -studentList\" }\r\n        if ($firstName -or $lastSurname -or $birthDate) {\r\n            if (!$firstName) { throw \"A value must be provided for -firstName if one is provided for either -lastSurname or -birthDate\" }\r\n            if (!$lastSurname) { throw \"A value must be provided for -lastSurname if one is provided for either -firstName or -birthDate\" }\r\n            if (!$birthDate) { \r\n                throw \"A value must be provided for -birthDate if one is provided for either -firstName or -lastSurnames\" \r\n            }\r\n        }\r\n        \r\n        # Do a FN/LN/DOB lookup\r\n        if ($firstName -and $lastSurname -and $birthDate) {\r\n            $ret = $null\r\n            $matchCount = 0\r\n                foreach ($student in $studentList.Values) {\r\n                if ($firstName.ToLower() -eq $student.firstName.ToLower() -and $lastSurname.ToLower() -eq $student.lastSurname.ToLower() -and $birthDate -eq $student.birthDate) {\r\n                    $ret = $student.studentUniqueId \r\n                    $matchCount ++\r\n                }\r\n            }\r\n            if ($ret) { \r\n                if ($matchCount -eq 1) { return $ret }\r\n                else {\r\n                    throw \"Found more than one Student entry with a name of '$firstName $lastSurname' and a birthdate of '$birthDate'.\"\r\n                }\r\n            }\r\n        }\r\n\r\n        # No ID found so return null\r\n        Write-Information \"Unable to find a matching StudentUniqueID value for Student ID '$studentId'\"\r\n    }\r\n    \r\n    function Get-StudentUniqueIDByFN_LN_DOB($firstName, $lastSurname, $birthDate){\r\n        # Load the list of students\r\n        Write-Information \"Loading list of students from the ods ...\"\r\n        #$apiVersion = $DataImport.ApiVersion\r\n        $STUDENTS_MAPPING_CACHE_KEY = \"Ods_Students_Map\"\r\n        $students = Get-AgentCacheItem -Key $STUDENTS_MAPPING_CACHE_KEY\r\n    \r\n        #$apiVersion=\"5.1\"\r\n\r\n        if (!$apiVersion) {  Write-Warning \"$([string]::Join(\",\",$apiVersion))\" }\r\n        \r\n        if (!$students) {\r\n            try {\r\n                \r\n                $s = Get-Students -apiVersion $apiVersion\r\n                Write-Information \"Loaded $($s.ValidStudents.Count) students records from the ODS.\"\r\n                $students = $s.ValidStudents            \r\n                New-AgentCacheItem -Key $STUDENTS_MAPPING_CACHE_KEY -Value $students\r\n            }\r\n            catch {\r\n                Write-Error \"Failed to load list of students from the ODS> Error returned is '$($_.Exception.Message)'\"\r\n                throw \"Fatal error while running Begin section of Preprocessor.\"\r\n            }\r\n            if ($students.Count -eq 0) {\r\n                throw \"No students were found in the ods\"\r\n            }\r\n        }\r\n        \r\n        $stdId = Get-StudentUniqueId -studentList $students -firstName $firstName -lastSurname $lastSurname -birthDate $birthDate\r\n        \r\n        return $stdId\r\n    }\r\n    \r\n    ## Helper functions        \r\n\r\n    # Convert an array list of data into a CSV line for output\r\n    function Get-CSVLine($inputData) {\r\n        $ret = \"\"\r\n        foreach ($cell in $inputData) {\r\n            if ($ret -ne \"\") { $ret += \",\" }\r\n            $ret += ('\"' + $cell + '\"')\r\n        }\r\n        return $ret\r\n    }\r\n    # Get a parsed csv line in an array of values (used for CSV data only)\r\n    function Get-ParsedRecordArray($line) {\r\n        # Deal with double-quote wrappers and the fact that fields may have embedded commas\r\n        # NOTE: This is vastly stupid, but we can't run Regex in ConstrainedLanguage mode so it is what it is.\r\n        if ($line.Contains('\",\"') -or $line.Contains(',\"') -or $line.Contains('\",')) {\r\n            $cleanLine = $line\r\n            $inQuote = $false\r\n            for ($i = 0; $i -le $cleanLine.length; $i++) {\r\n                if ($cleanLine[$i] -eq '\"') {\r\n                    $inQuote = !$inQuote\r\n                }\r\n                else {\r\n                    if ($cleanLine[$i] -eq \",\" -and $inQuote -eq $false) {\r\n                        $cleanLine = $cleanLine.Substring(0, $i) + \"^\" + $cleanLine.Substring($i + 1)\r\n                    }\r\n                }\r\n            }\r\n            $cleanLine = $cleanLine.Replace(\",\", \"\")\r\n            $fields = $cleanLine.split(\"^\")\r\n        }\r\n        else {\r\n            $fields = $line.split(\",\")\r\n        }\r\n        $ret = @()\r\n        for ($i = 0; $i -lt $fields.Length; $i++) {\r\n            $ret += $fields[$i].Replace('\"', '')\r\n        }\r\n        return $ret\r\n    }\r\n\r\n    # Parse Date from string\r\n    function Get-ParsedDate ($date, $inputFormat, $outputFormat = $null) {\r\n        <# \r\n            .SYNOPSIS\r\n                Parse a date string and returns it in the correct format.\r\n    \r\n            .PARAMETER date (required)\r\n                The date string to parse\r\n    \r\n            .PARAMETER inputFormat (required)\r\n                The expected format of the incoming date string\r\n    \r\n            .PARAMETER outputFormat (optional)\r\n                The desired format of the retured date string\r\n    \r\n            .OUTPUTS\r\n                If no outputFormat is provided then a Date object is returned\r\n    \r\n                If outputFormat is provided then a formatted string is returned\r\n    \r\n                If parsing fails for any reason then $null is returned\r\n        #>\r\n    \r\n        try {\r\n            $d = $([datetime]::ParseExact($date, $inputFormat, $null))\r\n            if ($outputFormat) {\r\n                $d = Get-Date -Date $d -Format $outputFormat\r\n            }\r\n            return $d\r\n        }\r\n        catch {\r\n            return $null\r\n        }\r\n    }\r\n\r\n    #Get School Year\r\n    function Get-SchoolYear($date) {\r\n        $month = [int]$date.Substring(0, $date.IndexOf(\"/\"));\r\n        $schoolYear = [int]$date.Substring($date.Length - 4);\r\n        if ($month -ge 7) {\r\n            $schoolYear += 1;\r\n        }\r\n        return $schoolYear.ToString();\r\n    }\r\n    \r\n    # Function to perform a single lookup.\r\n    function get-replacement($original){\r\n        if($original -eq 'Y'){\r\n            return \"true\"\r\n        }else{\r\n            if($original -eq 'N'){\r\n                return \"false\"\r\n            }\r\n        }\r\n        \r\n        ##should not get here\r\n        return $null\r\n    }\r\n    \r\n   \r\n    \r\n    # Add record to statistics indicating a record was not processed becuase of a validation error\r\n    function Get-StudentODSId($fileStudentId) {\r\n        if ($global:needStudentIdLookup) {\r\n            return $global:studentsIdMap[$fileStudentId]\r\n        }\r\n        else {\r\n            # StudentId matches ODS\r\n            return $fileStudentId\r\n        }\r\n    }\r\n    \r\n    # Type of StudentId that will be used from assessment file to match student in ODS\r\n    # Valid values 'District','State'\r\n    $studentIdType = \"State\" #this is not used for this template as we are using the fname , lname, and dob to find the studentid \r\n    $global:needStudentIdLookup = $false #this is not used for this template as we are using the fname , lname, and dob to find the studentid \r\n   \r\n    \r\n    ### Assessment fields\r\n\r\n    $global:fileColumnDelimiter = \",\"\r\n    \r\n   ######################\r\n  ### Columns Definition \r\n  ######################\r\n\r\n  $global:SRC_COLUMNS_StudentId = 'Student ID'\r\n  $global:SRC_COLUMNS_SchoolYear = 'Last Adjustment Date'\r\n\r\n\r\n   \r\n     function Get-StudentByNameAndDOB(){   \r\n\r\n        $srcColName_First = \"F_Name\"\r\n        $srcColName_Last = \"L_Name\"\r\n        $srcColName_DOB = \"DOB\"\r\n        $DoB = $row.$srcColName_DOB\r\n        if($DoB.Length -eq 7) {\r\n            $DoB = '0{0}' -f $DoB\r\n        }\r\n        $studDoB = Get-ParsedDate -date $DoB -inputFormat \"MMddyyyy\" -outputFormat \"yyyy-MM-dd\"\r\n        $stdId = Get-StudentUniqueIDByFN_LN_DOB -firstName $row.$srcColName_First -lastSurname $row.$srcColName_Last -birthDate $studDoB\r\n        ##should not get here\r\n        return $stdId\r\n    }\r\n    \r\n    function Get-CompleteDate(){   \r\n        $out_col_AdminDate = $null;\r\n        $srcColName = $srcInfo.SourceColumnName\r\n        $col_Date = $row.$srcColName\r\n        \r\n        if($col_Date.Length -eq 5) {\r\n            $col_Date = '0{0}' -f $col_Date\r\n        }\r\n        \r\n        if($col_Date.Length -eq 6){\r\n            $month = $col_Date.Substring(0,2)\r\n            $year = $col_Date.Substring(2,4)\r\n            $out_col_AdminDate = '{0}/01/{1}' -f $month,$year \r\n        }\r\n        return  $out_col_AdminDate\r\n    }\r\n\r\n    \r\n    #Api Version\r\n    $apiVersion = $DataImport.ApiVersion\r\n    # Custom/computed output columns. key: output column name, value: HashTable with source column name and other info\r\n    $global:CUSTOM_COLUMN_MAP = @{}\r\n    $global:CUSTOM_COLUMN_MAP.Add(\"DI_SchoolYear\", \r\n        @{ \"SourceColumnName\" = $global:SRC_COLUMNS_SchoolYear }) | Out-Null\r\n    $global:CUSTOM_COLUMN_MAP.Add(\"DI_StudentId\", \r\n        @{ \"SourceColumnName\" =  $global:SRC_COLUMNS_StudentId }) | Out-Null\r\n    $global:CUSTOM_COLUMN_MAP.Add(\"DI_StudentAssessmentIdentifier\", \r\n        @{ \"SourceColumnName\" = \"Last Adjustment Date\" }) | Out-Null\r\n    $global:CUSTOM_COLUMN_MAP.Add(\"DI_AdministrationDate\", \r\n        @{ \"SourceColumnName\" = \"Last Adjustment Date\" }) | Out-Null\r\n        \r\n}\r\n\r\n\r\n# Process each individual line of incoming data (the pipeline sends this one line at a time)\r\nprocess {\r\n    $currentLineNumber += 1\r\n    $global:statistics.rowsProcessed += 1\r\n\r\n    # Make sure we got something\r\n    if (!$line) { Write-Error \"Line $currentLineNumber does not contain any data\"; return }\r\n    \r\n\r\n    # If the first line pick out all of the headers\r\n    if ($currentLineNumber -eq 1) { \r\n\r\n        # We assume headers will not have commas in the names\r\n        $headerRow = Get-ParsedRecordArray -line $line\r\n        \r\n        # Loop thru headers to find and fix empty and duplicate headers\r\n        for ($i = 0; $i -lt $headerRow.Count; $i++) {\r\n            $item = $headerRow[$i]\r\n            $item = $item.Trim(' ')\r\n            \r\n            # handle empty headers\r\n            if (!$item) {\r\n                $newName = \"EMPTY-$i\"\r\n                Write-Warning \"Found empty column at position $($i + 1). Renaming column to '$newName'.\"\r\n                $item = $newName\r\n            }\r\n            # handle duplicate headers\r\n            if ($global:headersLookup.contains($item)) {\r\n                $newName = \"$item-$i\"\r\n                Write-Warning \"Found duplicate column name of '$item' at position $($i + 1). Renaming column to '$newName'.\"\r\n                $item = $newName\r\n            }\r\n            $global:inputHeaders += $item\r\n            $outputHeaders += $item            \r\n            $global:headersLookup.Add($item, $index) | Out-Null        \r\n        }\r\n\r\n        # Fixed Headers\r\n        # Order matters, output values must be extracted in this same order\r\n        # 1 - All columns needed from the file        \r\n        $fixedHeaders = $global:inputHeaders\r\n\r\n \r\n        # 2 - If there are custom headers add to output header line\r\n        if ($global:CUSTOM_COLUMN_MAP.Count) {            \r\n            $fixedHeaders += $( $global:CUSTOM_COLUMN_MAP.Keys | Sort-Object )\r\n        }\r\n        \r\n        Write-Output $(Get-CSVLine($fixedHeaders))        \r\n        return\r\n    }\r\n\r\n    # array, Ordered output values\r\n    $orderedOutputValues = @()\r\n    \r\n    # HashTable, will hold all input values for current line, used in case computed columns need to reference input values\r\n    $row = @{}\r\n\r\n    # 1 - add all values as they come in line\r\n    $row = ConvertFrom-Csv -InputObject $line -Header $global:inputHeaders\r\n    \r\n    $errorInCurrentRow = $false\r\n    $orderedOutputValues = Get-ParsedRecordArray -line $line       \r\n\r\n    # Validation will tell whether or not a record has the required values needed to be posted to ODS, if not valid add line number to show in summary\r\n    $passedValidation = $true\r\n    $validationId = $null\r\n    \r\n    # Process custom/computed columns\r\n    if ($global:CUSTOM_COLUMN_MAP.Count) {    \r\n        $Ommited_Assess_Subj_Count=0  \r\n        \r\n        foreach ($outColumnName in $( $global:CUSTOM_COLUMN_MAP.Keys | Sort-Object )) {\r\n            $srcInfo = $global:CUSTOM_COLUMN_MAP[$outColumnName]                \r\n            ### DataImport Assessment Custom Columns\r\n            switch -Exact ($outColumnName) {\r\n                # Student UniqueId\r\n                \"DI_StudentAssessmentIdentifier\" {\r\n                    $stdAssessmentId = $null;\r\n                    $srcColName = $srcInfo.SourceColumnName\r\n                    $col_Date = $row.$srcColName\r\n               \r\n                    $out_col_AdminDate= Get-ParsedDate -date  $col_Date -inputFormat \"M/d/yyyy\" -outputFormat \"MMddyyyy\"  \r\n                  \r\n                    if (!$out_col_AdminDate) {\r\n                        $passedValidation = $false\r\n                        $validationId = \"Invalid_StudentAssessmentIdentifier\"\r\n                        break\r\n                    }\r\n                   \r\n                    $orderedOutputValues += $out_col_AdminDate\r\n                    break\r\n\r\n                }\r\n\r\n                # StudentId\r\n                \"DI_StudentId\" {\r\n                $srcColName = $srcInfo.SourceColumnName\r\n                $stdId = Get-StudentODSId($row.$srcColName)\r\n                 Write-Warning \"$row.$srcColName\"\r\n                # Validation, this is a required field, if empty will be unable to post to ODS.\r\n                if (!$stdId) {\r\n                    $passedValidation = $false\r\n                    $validationId = \"InvalidStudentId\"\r\n                    break\r\n                }\r\n            \r\n                $orderedOutputValues += $stdId\r\n                break\r\n                }\r\n\r\n                # School Year\r\n                \"DI_SchoolYear\" {\r\n                    $out_col_year = $null;\r\n                    $srcColName = $srcInfo.SourceColumnName\r\n                    $col_Date = $row.$srcColName\r\n                    $out_col_year = Get-ParsedDate -date  $col_Date -inputFormat \"M/d/yyyy\" -outputFormat \"yyyy\"\r\n                    $out_col_yearInt = $out_col_year -as [int]\r\n                        \r\n                    # Validation, this is a required field, if empty will be unable to post to ODS\r\n                    if (!$out_col_year) {\r\n                        $passedValidation = $false\r\n                        $validationId = \"Invalid_SchoolYear\"\r\n                        break\r\n                    }\r\n                    $out_col_month = Get-ParsedDate -date  $col_Date -inputFormat \"M/d/yyyy\" -outputFormat \"MM\" \r\n                    $out_col_monthInt  =  $out_col_month -as [int]\r\n                    \r\n                    if($out_col_monthInt -ge 7){\r\n                    $schoolYear = $out_col_yearInt + 1\r\n                    } else { \r\n                    $schoolYear = $out_col_yearInt\r\n                    }\r\n\r\n                    $orderedOutputValues += $schoolYear\r\n                    break\r\n                }\r\n                \r\n                #AdministrationDate\r\n                \"DI_AdministrationDate\" {\r\n                    $out_col_AdminDate = $null;\r\n                    $srcColName = $srcInfo.SourceColumnName\r\n                    $col_Date = $row.$srcColName\r\n\r\n                    $out_col_AdminDate = Get-ParsedDate -date $col_Date -inputFormat \"M/d/yyyy\" -outputFormat \"MM-dd-yyyy\"\r\n                    # Validation, this is a required field, if empty will be unable to post to ODS\r\n                    if (!$out_col_AdminDate) {\r\n                        $passedValidation = $false\r\n                        $validationId = \"Invalid_AdministrationDate\"\r\n                        break\r\n                    }\r\n        \r\n                    $orderedOutputValues += $out_col_AdminDate\r\n                    break\r\n                }\r\n                \r\n                Default {\r\n                    # In case of no implementation for custom column add $null output to preserve output format and order\r\n                    $orderedOutputValues += $null\r\n                    break;\r\n                }               \r\n            }  \r\n        }\r\n    }        \r\n\r\n\r\n    # If not valid add to statistics to notify user at the end of execution and skip record and do not post current for current row this screening period to ODS\r\n    if (!$passedValidation) {\r\n        # Only print once per row\r\n        if (!$errorInCurrentRow) {\r\n            Write-Warning \"Invalid record see statistics summary for details.($currentLineNumber)\"\r\n        }            \r\n\r\n        # Check if this validation error already added for current screening period\r\n        if ($global:statistics.validations[$validationId]) {\r\n            $global:statistics.validations[$validationId] += $currentLineNumber\r\n        }\r\n        else {\r\n            $global:statistics.validations.Add($validationId, @($currentLineNumber)) | Out-Null\r\n        }\r\n        \r\n        # Skip current line do not pass values to DataImport\r\n        return\r\n    }\r\n    \r\n    # Output \r\n    Write-Output $(Get-CSVLine($orderedOutputValues))\r\n    $global:statistics.rowsLoaded ++    \r\n    \r\n\r\n    return\r\n}\r\n\r\n# end of processing\r\nend {\r\n     Write-Information \"SUMMARY: `\r\n                    Rows Processed: $($global:statistics.rowsProcessed); `\r\n                    Rows Loaded: $($global:statistics.rowsLoaded)\"\r\n\r\n     foreach ($validationId in $global:statistics.validations.Keys) {\r\n        Write-Warning \"Error reason: '$validationId'\"                \r\n        Write-Information \"Line number(s):\"\r\n        $lineNumbers = $global:statistics.validations[$validationId]\r\n        $errorThreshold = 50\r\n        if ($lineNumbers.Count -gt $errorThreshold) {\r\n            Write-Warning \"There are $($lineNumbers.Count) lines with errors. Will only print the first $errorThreshold line numbers where errors ocurred.\"\r\n            $lineNumbers = $lineNumbers[0..$($errorThreshold - 1)]\r\n        }\r\n        Write-Warning \"$([string]::Join(\",\",$lineNumbers))\"\r\n    }\r\n}",
                "requireOdsApiAccess": true,
                "hasAttribute": false
            }
        ]
    }
}